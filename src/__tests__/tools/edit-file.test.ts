import * as fs from 'fs/promises';import * as path from 'path';import { editFile } from '../../tools/edit-file';import { SafetyController } from '../../core/safety-controller';import { FileAnalyzer } from '../../core/file-analyzer';import { initializeSecurityController } from '../../core/security-controller-v2';describe('editFile tool', () => {  const testDir = path.resolve(__dirname, 'edit-file-test-dir');  const safety = new SafetyController();  const analyzer = new FileAnalyzer();  beforeAll(async () => {    await initializeSecurityController([testDir]);    await fs.mkdir(testDir, { recursive: true });  });  afterAll(async () => {    await fs.rm(testDir, { recursive: true, force: true });  });  it('should perform a simple literal replacement', async () => {    const filePath = path.join(testDir, 'literal.txt');    await fs.writeFile(filePath, 'hello world');    const result = await editFile(      { path: filePath, edits: [{ oldText: 'world', newText: 'friend' }] },      safety,      analyzer    );    expect(result.success).toBe(true);    const content = await fs.readFile(filePath, 'utf8');    expect(content).toBe('hello friend');  });  it('should perform a regex replacement', async () => {    const filePath = path.join(testDir, 'regex.txt');    await fs.writeFile(filePath, 'hello 123 world 456');    const result = await editFile(      { path: filePath, edits: [{ type: 'regex', pattern: '\\d+', replacement: 'number', flags: 'g' }] },      safety,      analyzer    );    expect(result.success).toBe(true);    const content = await fs.readFile(filePath, 'utf8');    expect(content).toBe('hello number world number');  });  it('should return an error if pattern is not found', async () => {    const filePath = path.join(testDir, 'not-found.txt');    await fs.writeFile(filePath, 'hello world');    const result = await editFile(      { path: filePath, edits: [{ oldText: 'galaxy', newText: 'friend' }] },      safety,      analyzer    );    expect(result.success).toBe(false);    if (!result.success) {      expect(result.error.code).toBe('pattern_not_found');    }  });  it('should perform a dry run without modifying the file', async () => {    const filePath = path.join(testDir, 'dry-run.txt');    const originalContent = 'hello world';    await fs.writeFile(filePath, originalContent);    const result = await editFile(      { path: filePath, edits: [{ oldText: 'world', newText: 'dry-run' }], dry_run: true },      safety,      analyzer    );    expect(result.success).toBe(true);    if (result.success) {      expect(result.message).toContain('Dry run completed');      expect(result.diff_output).toContain('-hello world');      expect(result.diff_output).toContain('+hello dry-run');    }    const content = await fs.readFile(filePath, 'utf8');    expect(content).toBe(originalContent);  });  it('should return an error for a non-existent file', async () => {    const filePath = path.join(testDir, 'non-existent-file.txt');    const result = await editFile(      { path: filePath, edits: [{ oldText: 'a', newText: 'b' }] },      safety,      analyzer    );    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.code).toBe('file_not_found');
    }  });});